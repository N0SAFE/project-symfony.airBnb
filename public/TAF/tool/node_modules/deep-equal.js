(function() {
    function r(e, n, t) {
        function o(i, f) {
            if (!n[i]) {
                if (!e[i]) { var c = "function" == typeof require && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); var a = new Error("Cannot find module '" + i + "'"); throw a.code = "MODULE_NOT_FOUND", a }
                var p = n[i] = { exports: {} };
                e[i][0].call(p.exports, function(r) { var n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t)
            }
            return n[i].exports
        }
        for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
        return o
    }
    return r
})()({
    1: [function(require, module, exports) {

    }, {}],
    2: [function(require, module, exports) {
        // shim for using process in browser
        var process = module.exports = {};

        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.

        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
            throw new Error('setTimeout has not been defined');
        }

        function defaultClearTimeout() {
            throw new Error('clearTimeout has not been defined');
        }
        (function() {
            try {
                if (typeof setTimeout === 'function') {
                    cachedSetTimeout = setTimeout;
                } else {
                    cachedSetTimeout = defaultSetTimout;
                }
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                if (typeof clearTimeout === 'function') {
                    cachedClearTimeout = clearTimeout;
                } else {
                    cachedClearTimeout = defaultClearTimeout;
                }
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        }())

        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
                //normal enviroments in sane situations
                return setTimeout(fun, 0);
            }
            // if setTimeout wasn't available but was latter defined
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
            }
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }


        }

        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
                //normal enviroments in sane situations
                return clearTimeout(marker);
            }
            // if clearTimeout wasn't available but was latter defined
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
            }
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedClearTimeout(marker);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                    return cachedClearTimeout.call(null, marker);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                    // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                    return cachedClearTimeout.call(this, marker);
                }
            }



        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
            if (!draining || !currentQueue) {
                return;
            }
            draining = false;
            if (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } else {
                queueIndex = -1;
            }
            if (queue.length) {
                drainQueue();
            }
        }

        function drainQueue() {
            if (draining) {
                return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;

            var len = queue.length;
            while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                    if (currentQueue) {
                        currentQueue[queueIndex].run();
                    }
                }
                queueIndex = -1;
                len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
        }

        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
            }
        };

        // v8 likes predictible objects
        function Item(fun, array) {
            this.fun = fun;
            this.array = array;
        }
        Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        };
        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = ''; // empty string to avoid regexp issues
        process.versions = {};

        function noop() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;

        process.listeners = function(name) { return [] }

        process.binding = function(name) {
            throw new Error('process.binding is not supported');
        };

        process.cwd = function() { return '/' };
        process.chdir = function(dir) {
            throw new Error('process.chdir is not supported');
        };
        process.umask = function() { return 0; };

    }, {}],
    3: [function(require, module, exports) {
        (function(global) {
            (function() {
                'use strict';

                var possibleNames = [
                    'BigInt64Array',
                    'BigUint64Array',
                    'Float32Array',
                    'Float64Array',
                    'Int16Array',
                    'Int32Array',
                    'Int8Array',
                    'Uint16Array',
                    'Uint32Array',
                    'Uint8Array',
                    'Uint8ClampedArray'
                ];

                var g = typeof globalThis === 'undefined' ? global : globalThis;

                module.exports = function availableTypedArrays() {
                    var out = [];
                    for (var i = 0; i < possibleNames.length; i++) {
                        if (typeof g[possibleNames[i]] === 'function') {
                            out[out.length] = possibleNames[i];
                        }
                    }
                    return out;
                };

            }).call(this)
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {}],
    4: [function(require, module, exports) {
        'use strict';

        var GetIntrinsic = require('get-intrinsic');

        var callBind = require('./');

        var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

        module.exports = function callBoundIntrinsic(name, allowMissing) {
            var intrinsic = GetIntrinsic(name, !!allowMissing);
            if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
                return callBind(intrinsic);
            }
            return intrinsic;
        };

    }, { "./": 5, "get-intrinsic": 13 }],
    5: [function(require, module, exports) {
        'use strict';

        var bind = require('function-bind');
        var GetIntrinsic = require('get-intrinsic');

        var $apply = GetIntrinsic('%Function.prototype.apply%');
        var $call = GetIntrinsic('%Function.prototype.call%');
        var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

        var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
        var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
        var $max = GetIntrinsic('%Math.max%');

        if ($defineProperty) {
            try {
                $defineProperty({}, 'a', { value: 1 });
            } catch (e) {
                // IE 8 has a broken defineProperty
                $defineProperty = null;
            }
        }

        module.exports = function callBind(originalFunction) {
            var func = $reflectApply(bind, $call, arguments);
            if ($gOPD && $defineProperty) {
                var desc = $gOPD(func, 'length');
                if (desc.configurable) {
                    // original length, plus the receiver, minus any additional arguments (after the receiver)
                    $defineProperty(
                        func,
                        'length', { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
                    );
                }
            }
            return func;
        };

        var applyBind = function applyBind() {
            return $reflectApply(bind, $apply, arguments);
        };

        if ($defineProperty) {
            $defineProperty(module.exports, 'apply', { value: applyBind });
        } else {
            module.exports.apply = applyBind;
        }

    }, { "function-bind": 12, "get-intrinsic": 13 }],
    6: [function(require, module, exports) {
        'use strict';

        var objectKeys = require('object-keys');
        var isArguments = require('is-arguments');
        var is = require('object-is');
        var isRegex = require('is-regex');
        var flags = require('regexp.prototype.flags');
        var isArray = require('isarray');
        var isDate = require('is-date-object');
        var whichBoxedPrimitive = require('which-boxed-primitive');
        var GetIntrinsic = require('get-intrinsic');
        var callBound = require('call-bind/callBound');
        var whichCollection = require('which-collection');
        var getIterator = require('es-get-iterator');
        var getSideChannel = require('side-channel');
        var whichTypedArray = require('which-typed-array');
        var assign = require('object.assign');

        var $getTime = callBound('Date.prototype.getTime');
        var gPO = Object.getPrototypeOf;
        var $objToString = callBound('Object.prototype.toString');

        var $Set = GetIntrinsic('%Set%', true);
        var $mapHas = callBound('Map.prototype.has', true);
        var $mapGet = callBound('Map.prototype.get', true);
        var $mapSize = callBound('Map.prototype.size', true);
        var $setAdd = callBound('Set.prototype.add', true);
        var $setDelete = callBound('Set.prototype.delete', true);
        var $setHas = callBound('Set.prototype.has', true);
        var $setSize = callBound('Set.prototype.size', true);

        // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L401-L414
        function setHasEqualElement(set, val1, opts, channel) {
            var i = getIterator(set);
            var result;
            while ((result = i.next()) && !result.done) {
                if (internalDeepEqual(val1, result.value, opts, channel)) { // eslint-disable-line no-use-before-define
                    // Remove the matching element to make sure we do not check that again.
                    $setDelete(set, result.value);
                    return true;
                }
            }

            return false;
        }

        // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L416-L439
        function findLooseMatchingPrimitives(prim) {
            if (typeof prim === 'undefined') {
                return null;
            }
            if (typeof prim === 'object') { // Only pass in null as object!
                return void 0;
            }
            if (typeof prim === 'symbol') {
                return false;
            }
            if (typeof prim === 'string' || typeof prim === 'number') {
                // Loose equal entries exist only if the string is possible to convert to a regular number and not NaN.
                return +prim === +prim; // eslint-disable-line no-implicit-coercion
            }
            return true;
        }

        // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L449-L460
        function mapMightHaveLoosePrim(a, b, prim, item, opts, channel) {
            var altValue = findLooseMatchingPrimitives(prim);
            if (altValue != null) {
                return altValue;
            }
            var curB = $mapGet(b, altValue);
            var looseOpts = assign({}, opts, { strict: false });
            if (
                (typeof curB === 'undefined' && !$mapHas(b, altValue))
                // eslint-disable-next-line no-use-before-define
                ||
                !internalDeepEqual(item, curB, looseOpts, channel)
            ) {
                return false;
            }
            // eslint-disable-next-line no-use-before-define
            return !$mapHas(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
        }

        // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L441-L447
        function setMightHaveLoosePrim(a, b, prim) {
            var altValue = findLooseMatchingPrimitives(prim);
            if (altValue != null) {
                return altValue;
            }

            return $setHas(b, altValue) && !$setHas(a, altValue);
        }

        // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L518-L533
        function mapHasEqualEntry(set, map, key1, item1, opts, channel) {
            var i = getIterator(set);
            var result;
            var key2;
            while ((result = i.next()) && !result.done) {
                key2 = result.value;
                if (
                    // eslint-disable-next-line no-use-before-define
                    internalDeepEqual(key1, key2, opts, channel)
                    // eslint-disable-next-line no-use-before-define
                    &&
                    internalDeepEqual(item1, $mapGet(map, key2), opts, channel)
                ) {
                    $setDelete(set, key2);
                    return true;
                }
            }

            return false;
        }

        function internalDeepEqual(actual, expected, options, channel) {
            var opts = options || {};

            // 7.1. All identical values are equivalent, as determined by ===.
            if (opts.strict ? is(actual, expected) : actual === expected) {
                return true;
            }

            var actualBoxed = whichBoxedPrimitive(actual);
            var expectedBoxed = whichBoxedPrimitive(expected);
            if (actualBoxed !== expectedBoxed) {
                return false;
            }

            // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.
            if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {
                return opts.strict ? is(actual, expected) : actual == expected; // eslint-disable-line eqeqeq
            }

            /*
             * 7.4. For all other Object pairs, including Array objects, equivalence is
             * determined by having the same number of owned properties (as verified
             * with Object.prototype.hasOwnProperty.call), the same set of keys
             * (although not necessarily the same order), equivalent values for every
             * corresponding key, and an identical 'prototype' property. Note: this
             * accounts for both named and indexed properties on Arrays.
             */
            // see https://github.com/nodejs/node/commit/d3aafd02efd3a403d646a3044adcf14e63a88d32 for memos/channel inspiration

            var hasActual = channel.has(actual);
            var hasExpected = channel.has(expected);
            var sentinel;
            if (hasActual && hasExpected) {
                if (channel.get(actual) === channel.get(expected)) {
                    return true;
                }
            } else {
                sentinel = {};
            }
            if (!hasActual) { channel.set(actual, sentinel); }
            if (!hasExpected) { channel.set(expected, sentinel); }

            // eslint-disable-next-line no-use-before-define
            return objEquiv(actual, expected, opts, channel);
        }

        function isBuffer(x) {
            if (!x || typeof x !== 'object' || typeof x.length !== 'number') {
                return false;
            }
            if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
                return false;
            }
            if (x.length > 0 && typeof x[0] !== 'number') {
                return false;
            }

            return !!(x.constructor && x.constructor.isBuffer && x.constructor.isBuffer(x));
        }

        function setEquiv(a, b, opts, channel) {
            if ($setSize(a) !== $setSize(b)) {
                return false;
            }
            var iA = getIterator(a);
            var iB = getIterator(b);
            var resultA;
            var resultB;
            var set;
            while ((resultA = iA.next()) && !resultA.done) {
                if (resultA.value && typeof resultA.value === 'object') {
                    if (!set) { set = new $Set(); }
                    $setAdd(set, resultA.value);
                } else if (!$setHas(b, resultA.value)) {
                    if (opts.strict) { return false; }
                    if (!setMightHaveLoosePrim(a, b, resultA.value)) {
                        return false;
                    }
                    if (!set) { set = new $Set(); }
                    $setAdd(set, resultA.value);
                }
            }
            if (set) {
                while ((resultB = iB.next()) && !resultB.done) {
                    // We have to check if a primitive value is already matching and only if it's not, go hunting for it.
                    if (resultB.value && typeof resultB.value === 'object') {
                        if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {
                            return false;
                        }
                    } else if (!opts.strict &&
                        !$setHas(a, resultB.value) &&
                        !setHasEqualElement(set, resultB.value, opts.strict, channel)
                    ) {
                        return false;
                    }
                }
                return $setSize(set) === 0;
            }
            return true;
        }

        function mapEquiv(a, b, opts, channel) {
            if ($mapSize(a) !== $mapSize(b)) {
                return false;
            }
            var iA = getIterator(a);
            var iB = getIterator(b);
            var resultA;
            var resultB;
            var set;
            var key;
            var item1;
            var item2;
            while ((resultA = iA.next()) && !resultA.done) {
                key = resultA.value[0];
                item1 = resultA.value[1];
                if (key && typeof key === 'object') {
                    if (!set) { set = new $Set(); }
                    $setAdd(set, key);
                } else {
                    item2 = $mapGet(b, key);
                    if ((typeof item2 === 'undefined' && !$mapHas(b, key)) || !internalDeepEqual(item1, item2, opts, channel)) {
                        if (opts.strict) {
                            return false;
                        }
                        if (!mapMightHaveLoosePrim(a, b, key, item1, opts, channel)) {
                            return false;
                        }
                        if (!set) { set = new $Set(); }
                        $setAdd(set, key);
                    }
                }
            }

            if (set) {
                while ((resultB = iB.next()) && !resultB.done) {
                    key = resultB.value[0];
                    item2 = resultB.value[1];
                    if (key && typeof key === 'object') {
                        if (!mapHasEqualEntry(set, a, key, item2, opts, channel)) {
                            return false;
                        }
                    } else if (!opts.strict &&
                        (!a.has(key) || !internalDeepEqual($mapGet(a, key), item2, opts, channel)) &&
                        !mapHasEqualEntry(set, a, key, item2, assign({}, opts, { strict: false }), channel)
                    ) {
                        return false;
                    }
                }
                return $setSize(set) === 0;
            }
            return true;
        }

        function objEquiv(a, b, opts, channel) {
            /* eslint max-statements: [2, 100], max-lines-per-function: [2, 120], max-depth: [2, 5] */
            var i, key;

            if (typeof a !== typeof b) { return false; }
            if (a == null || b == null) { return false; }

            if ($objToString(a) !== $objToString(b)) { return false; }

            if (isArguments(a) !== isArguments(b)) { return false; }

            var aIsArray = isArray(a);
            var bIsArray = isArray(b);
            if (aIsArray !== bIsArray) { return false; }

            // TODO: replace when a cross-realm brand check is available
            var aIsError = a instanceof Error;
            var bIsError = b instanceof Error;
            if (aIsError !== bIsError) { return false; }
            if (aIsError || bIsError) {
                if (a.name !== b.name || a.message !== b.message) { return false; }
            }

            var aIsRegex = isRegex(a);
            var bIsRegex = isRegex(b);
            if (aIsRegex !== bIsRegex) { return false; }
            if ((aIsRegex || bIsRegex) && (a.source !== b.source || flags(a) !== flags(b))) {
                return false;
            }

            var aIsDate = isDate(a);
            var bIsDate = isDate(b);
            if (aIsDate !== bIsDate) { return false; }
            if (aIsDate || bIsDate) { // && would work too, because both are true or both false here
                if ($getTime(a) !== $getTime(b)) { return false; }
            }
            if (opts.strict && gPO && gPO(a) !== gPO(b)) { return false; }

            if (whichTypedArray(a) !== whichTypedArray(b)) {
                return false;
            }

            var aIsBuffer = isBuffer(a);
            var bIsBuffer = isBuffer(b);
            if (aIsBuffer !== bIsBuffer) { return false; }
            if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here
                if (a.length !== b.length) { return false; }
                for (i = 0; i < a.length; i++) {
                    if (a[i] !== b[i]) { return false; }
                }
                return true;
            }

            if (typeof a !== typeof b) { return false; }

            var ka = objectKeys(a);
            var kb = objectKeys(b);
            // having the same number of owned properties (keys incorporates hasOwnProperty)
            if (ka.length !== kb.length) { return false; }

            // the same set of keys (although not necessarily the same order),
            ka.sort();
            kb.sort();
            // ~~~cheap key test
            for (i = ka.length - 1; i >= 0; i--) {
                if (ka[i] != kb[i]) { return false; } // eslint-disable-line eqeqeq
            }

            // equivalent values for every corresponding key, and ~~~possibly expensive deep test
            for (i = ka.length - 1; i >= 0; i--) {
                key = ka[i];
                if (!internalDeepEqual(a[key], b[key], opts, channel)) { return false; }
            }

            var aCollection = whichCollection(a);
            var bCollection = whichCollection(b);
            if (aCollection !== bCollection) {
                return false;
            }
            if (aCollection === 'Set' || bCollection === 'Set') { // aCollection === bCollection
                return setEquiv(a, b, opts, channel);
            }
            if (aCollection === 'Map') { // aCollection === bCollection
                return mapEquiv(a, b, opts, channel);
            }

            return true;
        }

        module.exports = function deepEqual(a, b, opts) {
            return internalDeepEqual(a, b, opts, getSideChannel());
        };

    }, { "call-bind/callBound": 4, "es-get-iterator": 9, "get-intrinsic": 13, "is-arguments": 19, "is-date-object": 22, "is-regex": 25, "isarray": 32, "object-is": 35, "object-keys": 39, "object.assign": 42, "regexp.prototype.flags": 46, "side-channel": 49, "which-boxed-primitive": 50, "which-collection": 51, "which-typed-array": 52 }],
    7: [function(require, module, exports) {
        'use strict';

        var keys = require('object-keys');
        var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

        var toStr = Object.prototype.toString;
        var concat = Array.prototype.concat;
        var origDefineProperty = Object.defineProperty;

        var isFunction = function(fn) {
            return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
        };

        var arePropertyDescriptorsSupported = function() {
            var obj = {};
            try {
                origDefineProperty(obj, 'x', { enumerable: false, value: obj });
                // eslint-disable-next-line no-unused-vars, no-restricted-syntax
                for (var _ in obj) { // jscs:ignore disallowUnusedVariables
                    return false;
                }
                return obj.x === obj;
            } catch (e) { /* this is IE 8. */
                return false;
            }
        };
        var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

        var defineProperty = function(object, name, value, predicate) {
            if (name in object && (!isFunction(predicate) || !predicate())) {
                return;
            }
            if (supportsDescriptors) {
                origDefineProperty(object, name, {
                    configurable: true,
                    enumerable: false,
                    value: value,
                    writable: true
                });
            } else {
                object[name] = value;
            }
        };

        var defineProperties = function(object, map) {
            var predicates = arguments.length > 2 ? arguments[2] : {};
            var props = keys(map);
            if (hasSymbols) {
                props = concat.call(props, Object.getOwnPropertySymbols(map));
            }
            for (var i = 0; i < props.length; i += 1) {
                defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
            }
        };

        defineProperties.supportsDescriptors = !!supportsDescriptors;

        module.exports = defineProperties;

    }, { "object-keys": 39 }],
    8: [function(require, module, exports) {
        'use strict';

        var GetIntrinsic = require('get-intrinsic');

        var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
        if ($gOPD) {
            try {
                $gOPD([], 'length');
            } catch (e) {
                // IE 8 has a broken gOPD
                $gOPD = null;
            }
        }

        module.exports = $gOPD;

    }, { "get-intrinsic": 13 }],
    9: [function(require, module, exports) {
        (function(process) {
            (function() {
                'use strict';

                /* eslint global-require: 0 */
                // the code is structured this way so that bundlers can
                // alias out `has-symbols` to `() => true` or `() => false` if your target
                // environments' Symbol capabilities are known, and then use
                // dead code elimination on the rest of this module.
                //
                // Similarly, `isarray` can be aliased to `Array.isArray` if
                // available in all target environments.

                var isArguments = require('is-arguments');

                if (require('has-symbols')() || require('has-symbols/shams')()) {
                    var $iterator = Symbol.iterator;
                    // Symbol is available natively or shammed
                    // natively:
                    //  - Chrome >= 38
                    //  - Edge 12-14?, Edge >= 15 for sure
                    //  - FF >= 36
                    //  - Safari >= 9
                    //  - node >= 0.12
                    module.exports = function getIterator(iterable) {
                        // alternatively, `iterable[$iterator]?.()`
                        if (iterable != null && typeof iterable[$iterator] !== 'undefined') {
                            return iterable[$iterator]();
                        }
                        if (isArguments(iterable)) {
                            // arguments objects lack Symbol.iterator
                            // - node 0.12
                            return Array.prototype[$iterator].call(iterable);
                        }
                    };
                } else {
                    // Symbol is not available, native or shammed
                    var isArray = require('isarray');
                    var isString = require('is-string');
                    var GetIntrinsic = require('get-intrinsic');
                    var $Map = GetIntrinsic('%Map%', true);
                    var $Set = GetIntrinsic('%Set%', true);
                    var callBound = require('call-bind/callBound');
                    var $arrayPush = callBound('Array.prototype.push');
                    var $charCodeAt = callBound('String.prototype.charCodeAt');
                    var $stringSlice = callBound('String.prototype.slice');

                    var advanceStringIndex = function advanceStringIndex(S, index) {
                        var length = S.length;
                        if ((index + 1) >= length) {
                            return index + 1;
                        }

                        var first = $charCodeAt(S, index);
                        if (first < 0xD800 || first > 0xDBFF) {
                            return index + 1;
                        }

                        var second = $charCodeAt(S, index + 1);
                        if (second < 0xDC00 || second > 0xDFFF) {
                            return index + 1;
                        }

                        return index + 2;
                    };

                    var getArrayIterator = function getArrayIterator(arraylike) {
                        var i = 0;
                        return {
                            next: function next() {
                                var done = i >= arraylike.length;
                                var value;
                                if (!done) {
                                    value = arraylike[i];
                                    i += 1;
                                }
                                return {
                                    done: done,
                                    value: value
                                };
                            }
                        };
                    };

                    var getNonCollectionIterator = function getNonCollectionIterator(iterable, noPrimordialCollections) {
                        if (isArray(iterable) || isArguments(iterable)) {
                            return getArrayIterator(iterable);
                        }
                        if (isString(iterable)) {
                            var i = 0;
                            return {
                                next: function next() {
                                    var nextIndex = advanceStringIndex(iterable, i);
                                    var value = $stringSlice(iterable, i, nextIndex);
                                    i = nextIndex;
                                    return {
                                        done: nextIndex > iterable.length,
                                        value: value
                                    };
                                }
                            };
                        }

                        // es6-shim and es-shims' es-map use a string "_es6-shim iterator_" property on different iterables, such as MapIterator.
                        if (noPrimordialCollections && typeof iterable['_es6-shim iterator_'] !== 'undefined') {
                            return iterable['_es6-shim iterator_']();
                        }
                    };

                    if (!$Map && !$Set) {
                        // the only language iterables are Array, String, arguments
                        // - Safari <= 6.0
                        // - Chrome < 38
                        // - node < 0.12
                        // - FF < 13
                        // - IE < 11
                        // - Edge < 11

                        module.exports = function getIterator(iterable) {
                            if (iterable != null) {
                                return getNonCollectionIterator(iterable, true);
                            }
                        };
                    } else {
                        // either Map or Set are available, but Symbol is not
                        // - es6-shim on an ES5 browser
                        // - Safari 6.2 (maybe 6.1?)
                        // - FF v[13, 36)
                        // - IE 11
                        // - Edge 11
                        // - Safari v[6, 9)

                        var isMap = require('is-map');
                        var isSet = require('is-set');

                        // Firefox >= 27, IE 11, Safari 6.2 - 9, Edge 11, es6-shim in older envs, all have forEach
                        var $mapForEach = callBound('Map.prototype.forEach', true);
                        var $setForEach = callBound('Set.prototype.forEach', true);
                        if (typeof process === 'undefined' || !process.versions || !process.versions.node) { // "if is not node"

                            // Firefox 17 - 26 has `.iterator()`, whose iterator `.next()` either
                            // returns a value, or throws a StopIteration object. These browsers
                            // do not have any other mechanism for iteration.
                            var $mapIterator = callBound('Map.prototype.iterator', true);
                            var $setIterator = callBound('Set.prototype.iterator', true);
                            var getStopIterationIterator = function(iterator) {
                                var done = false;
                                return {
                                    next: function next() {
                                        try {
                                            return {
                                                done: done,
                                                value: done ? undefined : iterator.next()
                                            };
                                        } catch (e) {
                                            done = true;
                                            return {
                                                done: true,
                                                value: undefined
                                            };
                                        }
                                    }
                                };
                            };
                        }
                        // Firefox 27-35, and some older es6-shim versions, use a string "@@iterator" property
                        // this returns a proper iterator object, so we should use it instead of forEach.
                        // newer es6-shim versions use a string "_es6-shim iterator_" property.
                        var $mapAtAtIterator = callBound('Map.prototype.@@iterator', true) || callBound('Map.prototype._es6-shim iterator_', true);
                        var $setAtAtIterator = callBound('Set.prototype.@@iterator', true) || callBound('Set.prototype._es6-shim iterator_', true);

                        var getCollectionIterator = function getCollectionIterator(iterable) {
                            if (isMap(iterable)) {
                                if ($mapIterator) {
                                    return getStopIterationIterator($mapIterator(iterable));
                                }
                                if ($mapAtAtIterator) {
                                    return $mapAtAtIterator(iterable);
                                }
                                if ($mapForEach) {
                                    var entries = [];
                                    $mapForEach(iterable, function(v, k) {
                                        $arrayPush(entries, [k, v]);
                                    });
                                    return getArrayIterator(entries);
                                }
                            }
                            if (isSet(iterable)) {
                                if ($setIterator) {
                                    return getStopIterationIterator($setIterator(iterable));
                                }
                                if ($setAtAtIterator) {
                                    return $setAtAtIterator(iterable);
                                }
                                if ($setForEach) {
                                    var values = [];
                                    $setForEach(iterable, function(v) {
                                        $arrayPush(values, v);
                                    });
                                    return getArrayIterator(values);
                                }
                            }
                        };

                        module.exports = function getIterator(iterable) {
                            return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
                        };
                    }
                }

            }).call(this)
        }).call(this, require('_process'))
    }, { "_process": 2, "call-bind/callBound": 4, "get-intrinsic": 13, "has-symbols": 15, "has-symbols/shams": 16, "is-arguments": 19, "is-map": 23, "is-set": 26, "is-string": 27, "isarray": 32 }],
    10: [function(require, module, exports) {

        var hasOwn = Object.prototype.hasOwnProperty;
        var toString = Object.prototype.toString;

        module.exports = function forEach(obj, fn, ctx) {
            if (toString.call(fn) !== '[object Function]') {
                throw new TypeError('iterator must be a function');
            }
            var l = obj.length;
            if (l === +l) {
                for (var i = 0; i < l; i++) {
                    fn.call(ctx, obj[i], i, obj);
                }
            } else {
                for (var k in obj) {
                    if (hasOwn.call(obj, k)) {
                        fn.call(ctx, obj[k], k, obj);
                    }
                }
            }
        };


    }, {}],
    11: [function(require, module, exports) {
        'use strict';

        /* eslint no-invalid-this: 1 */

        var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
        var slice = Array.prototype.slice;
        var toStr = Object.prototype.toString;
        var funcType = '[object Function]';

        module.exports = function bind(that) {
            var target = this;
            if (typeof target !== 'function' || toStr.call(target) !== funcType) {
                throw new TypeError(ERROR_MESSAGE + target);
            }
            var args = slice.call(arguments, 1);

            var bound;
            var binder = function() {
                if (this instanceof bound) {
                    var result = target.apply(
                        this,
                        args.concat(slice.call(arguments))
                    );
                    if (Object(result) === result) {
                        return result;
                    }
                    return this;
                } else {
                    return target.apply(
                        that,
                        args.concat(slice.call(arguments))
                    );
                }
            };

            var boundLength = Math.max(0, target.length - args.length);
            var boundArgs = [];
            for (var i = 0; i < boundLength; i++) {
                boundArgs.push('$' + i);
            }

            bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

            if (target.prototype) {
                var Empty = function Empty() {};
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                Empty.prototype = null;
            }

            return bound;
        };

    }, {}],
    12: [function(require, module, exports) {
        'use strict';

        var implementation = require('./implementation');

        module.exports = Function.prototype.bind || implementation;

    }, { "./implementation": 11 }],
    13: [function(require, module, exports) {
        'use strict';

        var undefined;

        var $SyntaxError = SyntaxError;
        var $Function = Function;
        var $TypeError = TypeError;

        // eslint-disable-next-line consistent-return
        var getEvalledConstructor = function(expressionSyntax) {
            try {
                return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
            } catch (e) {}
        };

        var $gOPD = Object.getOwnPropertyDescriptor;
        if ($gOPD) {
            try {
                $gOPD({}, '');
            } catch (e) {
                $gOPD = null; // this is IE 8, which has a broken gOPD
            }
        }

        var throwTypeError = function() {
            throw new $TypeError();
        };
        var ThrowTypeError = $gOPD ?
            (function() {
                try {
                    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                    arguments.callee; // IE 8 does not throw here
                    return throwTypeError;
                } catch (calleeThrows) {
                    try {
                        // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                        return $gOPD(arguments, 'callee').get;
                    } catch (gOPDthrows) {
                        return throwTypeError;
                    }
                }
            }()) :
            throwTypeError;

        var hasSymbols = require('has-symbols')();

        var getProto = Object.getPrototypeOf || function(x) { return x.__proto__; }; // eslint-disable-line no-proto

        var needsEval = {};

        var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

        var INTRINSICS = {
            '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
            '%Array%': Array,
            '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
            '%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
            '%AsyncFromSyncIteratorPrototype%': undefined,
            '%AsyncFunction%': needsEval,
            '%AsyncGenerator%': needsEval,
            '%AsyncGeneratorFunction%': needsEval,
            '%AsyncIteratorPrototype%': needsEval,
            '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
            '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
            '%Boolean%': Boolean,
            '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
            '%Date%': Date,
            '%decodeURI%': decodeURI,
            '%decodeURIComponent%': decodeURIComponent,
            '%encodeURI%': encodeURI,
            '%encodeURIComponent%': encodeURIComponent,
            '%Error%': Error,
            '%eval%': eval, // eslint-disable-line no-eval
            '%EvalError%': EvalError,
            '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
            '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
            '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
            '%Function%': $Function,
            '%GeneratorFunction%': needsEval,
            '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
            '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
            '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
            '%isFinite%': isFinite,
            '%isNaN%': isNaN,
            '%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
            '%JSON%': typeof JSON === 'object' ? JSON : undefined,
            '%Map%': typeof Map === 'undefined' ? undefined : Map,
            '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
            '%Math%': Math,
            '%Number%': Number,
            '%Object%': Object,
            '%parseFloat%': parseFloat,
            '%parseInt%': parseInt,
            '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
            '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
            '%RangeError%': RangeError,
            '%ReferenceError%': ReferenceError,
            '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
            '%RegExp%': RegExp,
            '%Set%': typeof Set === 'undefined' ? undefined : Set,
            '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
            '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
            '%String%': String,
            '%StringIteratorPrototype%': hasSymbols ? getProto('' [Symbol.iterator]()) : undefined,
            '%Symbol%': hasSymbols ? Symbol : undefined,
            '%SyntaxError%': $SyntaxError,
            '%ThrowTypeError%': ThrowTypeError,
            '%TypedArray%': TypedArray,
            '%TypeError%': $TypeError,
            '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
            '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
            '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
            '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
            '%URIError%': URIError,
            '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
            '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
            '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
        };

        var doEval = function doEval(name) {
            var value;
            if (name === '%AsyncFunction%') {
                value = getEvalledConstructor('async function () {}');
            } else if (name === '%GeneratorFunction%') {
                value = getEvalledConstructor('function* () {}');
            } else if (name === '%AsyncGeneratorFunction%') {
                value = getEvalledConstructor('async function* () {}');
            } else if (name === '%AsyncGenerator%') {
                var fn = doEval('%AsyncGeneratorFunction%');
                if (fn) {
                    value = fn.prototype;
                }
            } else if (name === '%AsyncIteratorPrototype%') {
                var gen = doEval('%AsyncGenerator%');
                if (gen) {
                    value = getProto(gen.prototype);
                }
            }

            INTRINSICS[name] = value;

            return value;
        };

        var LEGACY_ALIASES = {
            '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
            '%ArrayPrototype%': ['Array', 'prototype'],
            '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
            '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
            '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
            '%ArrayProto_values%': ['Array', 'prototype', 'values'],
            '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
            '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
            '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
            '%BooleanPrototype%': ['Boolean', 'prototype'],
            '%DataViewPrototype%': ['DataView', 'prototype'],
            '%DatePrototype%': ['Date', 'prototype'],
            '%ErrorPrototype%': ['Error', 'prototype'],
            '%EvalErrorPrototype%': ['EvalError', 'prototype'],
            '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
            '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
            '%FunctionPrototype%': ['Function', 'prototype'],
            '%Generator%': ['GeneratorFunction', 'prototype'],
            '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
            '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
            '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
            '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
            '%JSONParse%': ['JSON', 'parse'],
            '%JSONStringify%': ['JSON', 'stringify'],
            '%MapPrototype%': ['Map', 'prototype'],
            '%NumberPrototype%': ['Number', 'prototype'],
            '%ObjectPrototype%': ['Object', 'prototype'],
            '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
            '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
            '%PromisePrototype%': ['Promise', 'prototype'],
            '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
            '%Promise_all%': ['Promise', 'all'],
            '%Promise_reject%': ['Promise', 'reject'],
            '%Promise_resolve%': ['Promise', 'resolve'],
            '%RangeErrorPrototype%': ['RangeError', 'prototype'],
            '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
            '%RegExpPrototype%': ['RegExp', 'prototype'],
            '%SetPrototype%': ['Set', 'prototype'],
            '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
            '%StringPrototype%': ['String', 'prototype'],
            '%SymbolPrototype%': ['Symbol', 'prototype'],
            '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
            '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
            '%TypeErrorPrototype%': ['TypeError', 'prototype'],
            '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
            '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
            '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
            '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
            '%URIErrorPrototype%': ['URIError', 'prototype'],
            '%WeakMapPrototype%': ['WeakMap', 'prototype'],
            '%WeakSetPrototype%': ['WeakSet', 'prototype']
        };

        var bind = require('function-bind');
        var hasOwn = require('has');
        var $concat = bind.call(Function.call, Array.prototype.concat);
        var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
        var $replace = bind.call(Function.call, String.prototype.replace);
        var $strSlice = bind.call(Function.call, String.prototype.slice);

        /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
        var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
        var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
        var stringToPath = function stringToPath(string) {
            var first = $strSlice(string, 0, 1);
            var last = $strSlice(string, -1);
            if (first === '%' && last !== '%') {
                throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
            } else if (last === '%' && first !== '%') {
                throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
            }
            var result = [];
            $replace(string, rePropName, function(match, number, quote, subString) {
                result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
            });
            return result;
        };
        /* end adaptation */

        var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
            var intrinsicName = name;
            var alias;
            if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                alias = LEGACY_ALIASES[intrinsicName];
                intrinsicName = '%' + alias[0] + '%';
            }

            if (hasOwn(INTRINSICS, intrinsicName)) {
                var value = INTRINSICS[intrinsicName];
                if (value === needsEval) {
                    value = doEval(intrinsicName);
                }
                if (typeof value === 'undefined' && !allowMissing) {
                    throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
                }

                return {
                    alias: alias,
                    name: intrinsicName,
                    value: value
                };
            }

            throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
        };

        module.exports = function GetIntrinsic(name, allowMissing) {
            if (typeof name !== 'string' || name.length === 0) {
                throw new $TypeError('intrinsic name must be a non-empty string');
            }
            if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
                throw new $TypeError('"allowMissing" argument must be a boolean');
            }

            var parts = stringToPath(name);
            var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

            var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
            var intrinsicRealName = intrinsic.name;
            var value = intrinsic.value;
            var skipFurtherCaching = false;

            var alias = intrinsic.alias;
            if (alias) {
                intrinsicBaseName = alias[0];
                $spliceApply(parts, $concat([0, 1], alias));
            }

            for (var i = 1, isOwn = true; i < parts.length; i += 1) {
                var part = parts[i];
                var first = $strSlice(part, 0, 1);
                var last = $strSlice(part, -1);
                if (
                    (
                        (first === '"' || first === "'" || first === '`') ||
                        (last === '"' || last === "'" || last === '`')
                    ) &&
                    first !== last
                ) {
                    throw new $SyntaxError('property names with quotes must have matching quotes');
                }
                if (part === 'constructor' || !isOwn) {
                    skipFurtherCaching = true;
                }

                intrinsicBaseName += '.' + part;
                intrinsicRealName = '%' + intrinsicBaseName + '%';

                if (hasOwn(INTRINSICS, intrinsicRealName)) {
                    value = INTRINSICS[intrinsicRealName];
                } else if (value != null) {
                    if (!(part in value)) {
                        if (!allowMissing) {
                            throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                        }
                        return void undefined;
                    }
                    if ($gOPD && (i + 1) >= parts.length) {
                        var desc = $gOPD(value, part);
                        isOwn = !!desc;

                        // By convention, when a data property is converted to an accessor
                        // property to emulate a data property that does not suffer from
                        // the override mistake, that accessor's getter is marked with
                        // an `originalValue` property. Here, when we detect this, we
                        // uphold the illusion by pretending to see that original data
                        // property, i.e., returning the value rather than the getter
                        // itself.
                        if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                            value = desc.get;
                        } else {
                            value = value[part];
                        }
                    } else {
                        isOwn = hasOwn(value, part);
                        value = value[part];
                    }

                    if (isOwn && !skipFurtherCaching) {
                        INTRINSICS[intrinsicRealName] = value;
                    }
                }
            }
            return value;
        };

    }, { "function-bind": 12, "has": 18, "has-symbols": 15 }],
    14: [function(require, module, exports) {
        (function(global) {
            (function() {
                'use strict';

                var $BigInt = global.BigInt;

                module.exports = function hasNativeBigInts() {
                    return typeof $BigInt === 'function' &&
                        typeof BigInt === 'function' &&
                        typeof $BigInt(42) === 'bigint' // eslint-disable-line no-magic-numbers
                        &&
                        typeof BigInt(42) === 'bigint'; // eslint-disable-line no-magic-numbers
                };

            }).call(this)
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {}],
    15: [function(require, module, exports) {
        'use strict';

        var origSymbol = typeof Symbol !== 'undefined' && Symbol;
        var hasSymbolSham = require('./shams');

        module.exports = function hasNativeSymbols() {
            if (typeof origSymbol !== 'function') { return false; }
            if (typeof Symbol !== 'function') { return false; }
            if (typeof origSymbol('foo') !== 'symbol') { return false; }
            if (typeof Symbol('bar') !== 'symbol') { return false; }

            return hasSymbolSham();
        };

    }, { "./shams": 16 }],
    16: [function(require, module, exports) {
        'use strict';

        /* eslint complexity: [2, 18], max-statements: [2, 33] */
        module.exports = function hasSymbols() {
            if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
            if (typeof Symbol.iterator === 'symbol') { return true; }

            var obj = {};
            var sym = Symbol('test');
            var symObj = Object(sym);
            if (typeof sym === 'string') { return false; }

            if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
            if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

            // temp disabled per https://github.com/ljharb/object.assign/issues/17
            // if (sym instanceof Symbol) { return false; }
            // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
            // if (!(symObj instanceof Symbol)) { return false; }

            // if (typeof Symbol.prototype.toString !== 'function') { return false; }
            // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

            var symVal = 42;
            obj[sym] = symVal;
            for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
            if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

            if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

            var syms = Object.getOwnPropertySymbols(obj);
            if (syms.length !== 1 || syms[0] !== sym) { return false; }

            if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

            if (typeof Object.getOwnPropertyDescriptor === 'function') {
                var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
            }

            return true;
        };

    }, {}],
    17: [function(require, module, exports) {
        'use strict';

        var hasSymbols = require('has-symbols/shams');

        module.exports = function hasToStringTagShams() {
            return hasSymbols() && !!Symbol.toStringTag;
        };

    }, { "has-symbols/shams": 16 }],
    18: [function(require, module, exports) {
        'use strict';

        var bind = require('function-bind');

        module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

    }, { "function-bind": 12 }],
    19: [function(require, module, exports) {
        'use strict';

        var hasToStringTag = require('has-tostringtag/shams')();
        var callBound = require('call-bind/callBound');

        var $toString = callBound('Object.prototype.toString');

        var isStandardArguments = function isArguments(value) {
            if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
                return false;
            }
            return $toString(value) === '[object Arguments]';
        };

        var isLegacyArguments = function isArguments(value) {
            if (isStandardArguments(value)) {
                return true;
            }
            return value !== null &&
                typeof value === 'object' &&
                typeof value.length === 'number' &&
                value.length >= 0 &&
                $toString(value) !== '[object Array]' &&
                $toString(value.callee) === '[object Function]';
        };

        var supportsStandardArguments = (function() {
            return isStandardArguments(arguments);
        }());

        isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

        module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

    }, { "call-bind/callBound": 4, "has-tostringtag/shams": 17 }],
    20: [function(require, module, exports) {
        'use strict';

        var hasBigInts = require('has-bigints')();

        if (hasBigInts) {
            var bigIntValueOf = BigInt.prototype.valueOf;
            var tryBigInt = function tryBigIntObject(value) {
                try {
                    bigIntValueOf.call(value);
                    return true;
                } catch (e) {}
                return false;
            };

            module.exports = function isBigInt(value) {
                if (
                    value === null ||
                    typeof value === 'undefined' ||
                    typeof value === 'boolean' ||
                    typeof value === 'string' ||
                    typeof value === 'number' ||
                    typeof value === 'symbol' ||
                    typeof value === 'function'
                ) {
                    return false;
                }
                if (typeof value === 'bigint') {
                    return true;
                }

                return tryBigInt(value);
            };
        } else {
            module.exports = function isBigInt(value) {
                return false && value;
            };
        }

    }, { "has-bigints": 14 }],
    21: [function(require, module, exports) {
        'use strict';

        var callBound = require('call-bind/callBound');
        var $boolToStr = callBound('Boolean.prototype.toString');
        var $toString = callBound('Object.prototype.toString');

        var tryBooleanObject = function booleanBrandCheck(value) {
            try {
                $boolToStr(value);
                return true;
            } catch (e) {
                return false;
            }
        };
        var boolClass = '[object Boolean]';
        var hasToStringTag = require('has-tostringtag/shams')();

        module.exports = function isBoolean(value) {
            if (typeof value === 'boolean') {
                return true;
            }
            if (value === null || typeof value !== 'object') {
                return false;
            }
            return hasToStringTag && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString(value) === boolClass;
        };

    }, { "call-bind/callBound": 4, "has-tostringtag/shams": 17 }],
    22: [function(require, module, exports) {
        'use strict';

        var getDay = Date.prototype.getDay;
        var tryDateObject = function tryDateGetDayCall(value) {
            try {
                getDay.call(value);
                return true;
            } catch (e) {
                return false;
            }
        };

        var toStr = Object.prototype.toString;
        var dateClass = '[object Date]';
        var hasToStringTag = require('has-tostringtag/shams')();

        module.exports = function isDateObject(value) {
            if (typeof value !== 'object' || value === null) {
                return false;
            }
            return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
        };

    }, { "has-tostringtag/shams": 17 }],
    23: [function(require, module, exports) {
        'use strict';

        var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
        var $Set = typeof Set === 'function' && Set.prototype ? Set : null;

        var exported;

        if (!$Map) {
            // eslint-disable-next-line no-unused-vars
            exported = function isMap(x) {
                // `Map` is not present in this environment.
                return false;
            };
        }

        var $mapHas = $Map ? Map.prototype.has : null;
        var $setHas = $Set ? Set.prototype.has : null;
        if (!exported && !$mapHas) {
            // eslint-disable-next-line no-unused-vars
            exported = function isMap(x) {
                // `Map` does not have a `has` method
                return false;
            };
        }

        module.exports = exported || function isMap(x) {
            if (!x || typeof x !== 'object') {
                return false;
            }
            try {
                $mapHas.call(x);
                if ($setHas) {
                    try {
                        $setHas.call(x);
                    } catch (e) {
                        return true;
                    }
                }
                return x instanceof $Map; // core-js workaround, pre-v2.5.0
            } catch (e) {}
            return false;
        };

    }, {}],
    24: [function(require, module, exports) {
        'use strict';

        var numToStr = Number.prototype.toString;
        var tryNumberObject = function tryNumberObject(value) {
            try {
                numToStr.call(value);
                return true;
            } catch (e) {
                return false;
            }
        };
        var toStr = Object.prototype.toString;
        var numClass = '[object Number]';
        var hasToStringTag = require('has-tostringtag/shams')();

        module.exports = function isNumberObject(value) {
            if (typeof value === 'number') {
                return true;
            }
            if (typeof value !== 'object') {
                return false;
            }
            return hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;
        };

    }, { "has-tostringtag/shams": 17 }],
    25: [function(require, module, exports) {
        'use strict';

        var callBound = require('call-bind/callBound');
        var hasToStringTag = require('has-tostringtag/shams')();
        var has;
        var $exec;
        var isRegexMarker;
        var badStringifier;

        if (hasToStringTag) {
            has = callBound('Object.prototype.hasOwnProperty');
            $exec = callBound('RegExp.prototype.exec');
            isRegexMarker = {};

            var throwRegexMarker = function() {
                throw isRegexMarker;
            };
            badStringifier = {
                toString: throwRegexMarker,
                valueOf: throwRegexMarker
            };

            if (typeof Symbol.toPrimitive === 'symbol') {
                badStringifier[Symbol.toPrimitive] = throwRegexMarker;
            }
        }

        var $toString = callBound('Object.prototype.toString');
        var gOPD = Object.getOwnPropertyDescriptor;
        var regexClass = '[object RegExp]';

        module.exports = hasToStringTag
            // eslint-disable-next-line consistent-return
            ?

            function isRegex(value) {
                if (!value || typeof value !== 'object') {
                    return false;
                }

                var descriptor = gOPD(value, 'lastIndex');
                var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
                if (!hasLastIndexDataProperty) {
                    return false;
                }

                try {
                    $exec(value, badStringifier);
                } catch (e) {
                    return e === isRegexMarker;
                }
            } :
            function isRegex(value) {
                // In older browsers, typeof regex incorrectly returns 'function'
                if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
                    return false;
                }

                return $toString(value) === regexClass;
            };

    }, { "call-bind/callBound": 4, "has-tostringtag/shams": 17 }],
    26: [function(require, module, exports) {
        'use strict';

        var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
        var $Set = typeof Set === 'function' && Set.prototype ? Set : null;

        var exported;

        if (!$Set) {
            // eslint-disable-next-line no-unused-vars
            exported = function isSet(x) {
                // `Set` is not present in this environment.
                return false;
            };
        }

        var $mapHas = $Map ? Map.prototype.has : null;
        var $setHas = $Set ? Set.prototype.has : null;
        if (!exported && !$setHas) {
            // eslint-disable-next-line no-unused-vars
            exported = function isSet(x) {
                // `Set` does not have a `has` method
                return false;
            };
        }

        module.exports = exported || function isSet(x) {
            if (!x || typeof x !== 'object') {
                return false;
            }
            try {
                $setHas.call(x);
                if ($mapHas) {
                    try {
                        $mapHas.call(x);
                    } catch (e) {
                        return true;
                    }
                }
                return x instanceof $Set; // core-js workaround, pre-v2.5.0
            } catch (e) {}
            return false;
        };

    }, {}],
    27: [function(require, module, exports) {
        'use strict';

        var strValue = String.prototype.valueOf;
        var tryStringObject = function tryStringObject(value) {
            try {
                strValue.call(value);
                return true;
            } catch (e) {
                return false;
            }
        };
        var toStr = Object.prototype.toString;
        var strClass = '[object String]';
        var hasToStringTag = require('has-tostringtag/shams')();

        module.exports = function isString(value) {
            if (typeof value === 'string') {
                return true;
            }
            if (typeof value !== 'object') {
                return false;
            }
            return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
        };

    }, { "has-tostringtag/shams": 17 }],
    28: [function(require, module, exports) {
        'use strict';

        var toStr = Object.prototype.toString;
        var hasSymbols = require('has-symbols')();

        if (hasSymbols) {
            var symToStr = Symbol.prototype.toString;
            var symStringRegex = /^Symbol\(.*\)$/;
            var isSymbolObject = function isRealSymbolObject(value) {
                if (typeof value.valueOf() !== 'symbol') {
                    return false;
                }
                return symStringRegex.test(symToStr.call(value));
            };

            module.exports = function isSymbol(value) {
                if (typeof value === 'symbol') {
                    return true;
                }
                if (toStr.call(value) !== '[object Symbol]') {
                    return false;
                }
                try {
                    return isSymbolObject(value);
                } catch (e) {
                    return false;
                }
            };
        } else {

            module.exports = function isSymbol(value) {
                // this environment does not support Symbols.
                return false && value;
            };
        }

    }, { "has-symbols": 15 }],
    29: [function(require, module, exports) {
        (function(global) {
            (function() {
                'use strict';

                var forEach = require('foreach');
                var availableTypedArrays = require('available-typed-arrays');
                var callBound = require('call-bind/callBound');

                var $toString = callBound('Object.prototype.toString');
                var hasToStringTag = require('has-tostringtag/shams')();

                var g = typeof globalThis === 'undefined' ? global : globalThis;
                var typedArrays = availableTypedArrays();

                var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
                    for (var i = 0; i < array.length; i += 1) {
                        if (array[i] === value) {
                            return i;
                        }
                    }
                    return -1;
                };
                var $slice = callBound('String.prototype.slice');
                var toStrTags = {};
                var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
                var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
                if (hasToStringTag && gOPD && getPrototypeOf) {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        if (Symbol.toStringTag in arr) {
                            var proto = getPrototypeOf(arr);
                            var descriptor = gOPD(proto, Symbol.toStringTag);
                            if (!descriptor) {
                                var superProto = getPrototypeOf(proto);
                                descriptor = gOPD(superProto, Symbol.toStringTag);
                            }
                            toStrTags[typedArray] = descriptor.get;
                        }
                    });
                }

                var tryTypedArrays = function tryAllTypedArrays(value) {
                    var anyTrue = false;
                    forEach(toStrTags, function(getter, typedArray) {
                        if (!anyTrue) {
                            try {
                                anyTrue = getter.call(value) === typedArray;
                            } catch (e) { /**/ }
                        }
                    });
                    return anyTrue;
                };

                module.exports = function isTypedArray(value) {
                    if (!value || typeof value !== 'object') { return false; }
                    if (!hasToStringTag || !(Symbol.toStringTag in value)) {
                        var tag = $slice($toString(value), 8, -1);
                        return $indexOf(typedArrays, tag) > -1;
                    }
                    if (!gOPD) { return false; }
                    return tryTypedArrays(value);
                };

            }).call(this)
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, { "available-typed-arrays": 3, "call-bind/callBound": 4, "es-abstract/helpers/getOwnPropertyDescriptor": 8, "foreach": 10, "has-tostringtag/shams": 17 }],
    30: [function(require, module, exports) {
        'use strict';

        var $WeakMap = typeof WeakMap === 'function' && WeakMap.prototype ? WeakMap : null;
        var $WeakSet = typeof WeakSet === 'function' && WeakSet.prototype ? WeakSet : null;

        var exported;

        if (!$WeakMap) {
            // eslint-disable-next-line no-unused-vars
            exported = function isWeakMap(x) {
                // `WeakMap` is not present in this environment.
                return false;
            };
        }

        var $mapHas = $WeakMap ? $WeakMap.prototype.has : null;
        var $setHas = $WeakSet ? $WeakSet.prototype.has : null;
        if (!exported && !$mapHas) {
            // eslint-disable-next-line no-unused-vars
            exported = function isWeakMap(x) {
                // `WeakMap` does not have a `has` method
                return false;
            };
        }

        module.exports = exported || function isWeakMap(x) {
            if (!x || typeof x !== 'object') {
                return false;
            }
            try {
                $mapHas.call(x, $mapHas);
                if ($setHas) {
                    try {
                        $setHas.call(x, $setHas);
                    } catch (e) {
                        return true;
                    }
                }
                return x instanceof $WeakMap; // core-js workaround, pre-v3
            } catch (e) {}
            return false;
        };

    }, {}],
    31: [function(require, module, exports) {
        'use strict';

        var GetIntrinsic = require('get-intrinsic');
        var callBound = require('call-bind/callBound');

        var $WeakSet = GetIntrinsic('%WeakSet%', true);

        var $setHas = callBound('WeakSet.prototype.has', true);

        if ($setHas) {
            var $mapHas = callBound('WeakMap.prototype.has', true);

            module.exports = function isWeakSet(x) {
                if (!x || typeof x !== 'object') {
                    return false;
                }
                try {
                    $setHas(x, $setHas);
                    if ($mapHas) {
                        try {
                            $mapHas(x, $mapHas);
                        } catch (e) {
                            return true;
                        }
                    }
                    return x instanceof $WeakSet; // core-js workaround, pre-v3
                } catch (e) {}
                return false;
            };
        } else {
            // eslint-disable-next-line no-unused-vars
            module.exports = function isWeakSet(x) {
                // `WeakSet` does not exist, or does not have a `has` method
                return false;
            };
        }

    }, { "call-bind/callBound": 4, "get-intrinsic": 13 }],
    32: [function(require, module, exports) {
        var toString = {}.toString;

        module.exports = Array.isArray || function(arr) {
            return toString.call(arr) == '[object Array]';
        };

    }, {}],
    33: [function(require, module, exports) {
        var hasMap = typeof Map === 'function' && Map.prototype;
        var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
        var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
        var mapForEach = hasMap && Map.prototype.forEach;
        var hasSet = typeof Set === 'function' && Set.prototype;
        var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
        var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
        var setForEach = hasSet && Set.prototype.forEach;
        var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
        var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
        var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
        var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
        var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
        var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
        var booleanValueOf = Boolean.prototype.valueOf;
        var objectToString = Object.prototype.toString;
        var functionToString = Function.prototype.toString;
        var $match = String.prototype.match;
        var $slice = String.prototype.slice;
        var $replace = String.prototype.replace;
        var $toUpperCase = String.prototype.toUpperCase;
        var $toLowerCase = String.prototype.toLowerCase;
        var $test = RegExp.prototype.test;
        var $concat = Array.prototype.concat;
        var $join = Array.prototype.join;
        var $arrSlice = Array.prototype.slice;
        var $floor = Math.floor;
        var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
        var gOPS = Object.getOwnPropertySymbols;
        var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
        var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
        // ie, `has-tostringtag/shams
        var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol') ?
            Symbol.toStringTag :
            null;
        var isEnumerable = Object.prototype.propertyIsEnumerable;

        var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
            [].__proto__ === Array.prototype // eslint-disable-line no-proto
            ?

            function(O) {
                return O.__proto__; // eslint-disable-line no-proto
            } :
            null
        );

        function addNumericSeparator(num, str) {
            if (
                num === Infinity ||
                num === -Infinity ||
                num !== num ||
                (num && num > -1000 && num < 1000) ||
                $test.call(/e/, str)
            ) {
                return str;
            }
            var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
            if (typeof num === 'number') {
                var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
                if (int !== num) {
                    var intStr = String(int);
                    var dec = $slice.call(str, intStr.length + 1);
                    return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
                }
            }
            return $replace.call(str, sepRegex, '$&_');
        }

        var inspectCustom = require('./util.inspect').custom;
        var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;

        module.exports = function inspect_(obj, options, depth, seen) {
            var opts = options || {};

            if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
                throw new TypeError('option "quoteStyle" must be "single" or "double"');
            }
            if (
                has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number' ?
                    opts.maxStringLength < 0 && opts.maxStringLength !== Infinity :
                    opts.maxStringLength !== null
                )
            ) {
                throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
            }
            var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
            if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
                throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
            }

            if (
                has(opts, 'indent') &&
                opts.indent !== null &&
                opts.indent !== '\t' &&
                !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
            ) {
                throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
            }
            if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
                throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
            }
            var numericSeparator = opts.numericSeparator;

            if (typeof obj === 'undefined') {
                return 'undefined';
            }
            if (obj === null) {
                return 'null';
            }
            if (typeof obj === 'boolean') {
                return obj ? 'true' : 'false';
            }

            if (typeof obj === 'string') {
                return inspectString(obj, opts);
            }
            if (typeof obj === 'number') {
                if (obj === 0) {
                    return Infinity / obj > 0 ? '0' : '-0';
                }
                var str = String(obj);
                return numericSeparator ? addNumericSeparator(obj, str) : str;
            }
            if (typeof obj === 'bigint') {
                var bigIntStr = String(obj) + 'n';
                return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
            }

            var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
            if (typeof depth === 'undefined') { depth = 0; }
            if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
                return isArray(obj) ? '[Array]' : '[Object]';
            }

            var indent = getIndent(opts, depth);

            if (typeof seen === 'undefined') {
                seen = [];
            } else if (indexOf(seen, obj) >= 0) {
                return '[Circular]';
            }

            function inspect(value, from, noIndent) {
                if (from) {
                    seen = $arrSlice.call(seen);
                    seen.push(from);
                }
                if (noIndent) {
                    var newOpts = {
                        depth: opts.depth
                    };
                    if (has(opts, 'quoteStyle')) {
                        newOpts.quoteStyle = opts.quoteStyle;
                    }
                    return inspect_(value, newOpts, depth + 1, seen);
                }
                return inspect_(value, opts, depth + 1, seen);
            }

            if (typeof obj === 'function') {
                var name = nameOf(obj);
                var keys = arrObjKeys(obj, inspect);
                return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
            }
            if (isSymbol(obj)) {
                var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
                return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
            }
            if (isElement(obj)) {
                var s = '<' + $toLowerCase.call(String(obj.nodeName));
                var attrs = obj.attributes || [];
                for (var i = 0; i < attrs.length; i++) {
                    s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
                }
                s += '>';
                if (obj.childNodes && obj.childNodes.length) { s += '...'; }
                s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
                return s;
            }
            if (isArray(obj)) {
                if (obj.length === 0) { return '[]'; }
                var xs = arrObjKeys(obj, inspect);
                if (indent && !singleLineValues(xs)) {
                    return '[' + indentedJoin(xs, indent) + ']';
                }
                return '[ ' + $join.call(xs, ', ') + ' ]';
            }
            if (isError(obj)) {
                var parts = arrObjKeys(obj, inspect);
                if ('cause' in obj && !isEnumerable.call(obj, 'cause')) {
                    return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
                }
                if (parts.length === 0) { return '[' + String(obj) + ']'; }
                return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
            }
            if (typeof obj === 'object' && customInspect) {
                if (inspectSymbol && typeof obj[inspectSymbol] === 'function') {
                    return obj[inspectSymbol]();
                } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
                    return obj.inspect();
                }
            }
            if (isMap(obj)) {
                var mapParts = [];
                mapForEach.call(obj, function(value, key) {
                    mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
                });
                return collectionOf('Map', mapSize.call(obj), mapParts, indent);
            }
            if (isSet(obj)) {
                var setParts = [];
                setForEach.call(obj, function(value) {
                    setParts.push(inspect(value, obj));
                });
                return collectionOf('Set', setSize.call(obj), setParts, indent);
            }
            if (isWeakMap(obj)) {
                return weakCollectionOf('WeakMap');
            }
            if (isWeakSet(obj)) {
                return weakCollectionOf('WeakSet');
            }
            if (isWeakRef(obj)) {
                return weakCollectionOf('WeakRef');
            }
            if (isNumber(obj)) {
                return markBoxed(inspect(Number(obj)));
            }
            if (isBigInt(obj)) {
                return markBoxed(inspect(bigIntValueOf.call(obj)));
            }
            if (isBoolean(obj)) {
                return markBoxed(booleanValueOf.call(obj));
            }
            if (isString(obj)) {
                return markBoxed(inspect(String(obj)));
            }
            if (!isDate(obj) && !isRegExp(obj)) {
                var ys = arrObjKeys(obj, inspect);
                var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
                var protoTag = obj instanceof Object ? '' : 'null prototype';
                var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
                var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
                var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
                if (ys.length === 0) { return tag + '{}'; }
                if (indent) {
                    return tag + '{' + indentedJoin(ys, indent) + '}';
                }
                return tag + '{ ' + $join.call(ys, ', ') + ' }';
            }
            return String(obj);
        };

        function wrapQuotes(s, defaultStyle, opts) {
            var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
            return quoteChar + s + quoteChar;
        }

        function quote(s) {
            return $replace.call(String(s), /"/g, '&quot;');
        }

        function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

        function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

        function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

        function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

        function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

        function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

        function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

        // Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
        function isSymbol(obj) {
            if (hasShammedSymbols) {
                return obj && typeof obj === 'object' && obj instanceof Symbol;
            }
            if (typeof obj === 'symbol') {
                return true;
            }
            if (!obj || typeof obj !== 'object' || !symToString) {
                return false;
            }
            try {
                symToString.call(obj);
                return true;
            } catch (e) {}
            return false;
        }

        function isBigInt(obj) {
            if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
                return false;
            }
            try {
                bigIntValueOf.call(obj);
                return true;
            } catch (e) {}
            return false;
        }

        var hasOwn = Object.prototype.hasOwnProperty || function(key) { return key in this; };

        function has(obj, key) {
            return hasOwn.call(obj, key);
        }

        function toStr(obj) {
            return objectToString.call(obj);
        }

        function nameOf(f) {
            if (f.name) { return f.name; }
            var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
            if (m) { return m[1]; }
            return null;
        }

        function indexOf(xs, x) {
            if (xs.indexOf) { return xs.indexOf(x); }
            for (var i = 0, l = xs.length; i < l; i++) {
                if (xs[i] === x) { return i; }
            }
            return -1;
        }

        function isMap(x) {
            if (!mapSize || !x || typeof x !== 'object') {
                return false;
            }
            try {
                mapSize.call(x);
                try {
                    setSize.call(x);
                } catch (s) {
                    return true;
                }
                return x instanceof Map; // core-js workaround, pre-v2.5.0
            } catch (e) {}
            return false;
        }

        function isWeakMap(x) {
            if (!weakMapHas || !x || typeof x !== 'object') {
                return false;
            }
            try {
                weakMapHas.call(x, weakMapHas);
                try {
                    weakSetHas.call(x, weakSetHas);
                } catch (s) {
                    return true;
                }
                return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
            } catch (e) {}
            return false;
        }

        function isWeakRef(x) {
            if (!weakRefDeref || !x || typeof x !== 'object') {
                return false;
            }
            try {
                weakRefDeref.call(x);
                return true;
            } catch (e) {}
            return false;
        }

        function isSet(x) {
            if (!setSize || !x || typeof x !== 'object') {
                return false;
            }
            try {
                setSize.call(x);
                try {
                    mapSize.call(x);
                } catch (m) {
                    return true;
                }
                return x instanceof Set; // core-js workaround, pre-v2.5.0
            } catch (e) {}
            return false;
        }

        function isWeakSet(x) {
            if (!weakSetHas || !x || typeof x !== 'object') {
                return false;
            }
            try {
                weakSetHas.call(x, weakSetHas);
                try {
                    weakMapHas.call(x, weakMapHas);
                } catch (s) {
                    return true;
                }
                return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
            } catch (e) {}
            return false;
        }

        function isElement(x) {
            if (!x || typeof x !== 'object') { return false; }
            if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
                return true;
            }
            return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
        }

        function inspectString(str, opts) {
            if (str.length > opts.maxStringLength) {
                var remaining = str.length - opts.maxStringLength;
                var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
                return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
            }
            // eslint-disable-next-line no-control-regex
            var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
            return wrapQuotes(s, 'single', opts);
        }

        function lowbyte(c) {
            var n = c.charCodeAt(0);
            var x = {
                8: 'b',
                9: 't',
                10: 'n',
                12: 'f',
                13: 'r'
            }[n];
            if (x) { return '\\' + x; }
            return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
        }

        function markBoxed(str) {
            return 'Object(' + str + ')';
        }

        function weakCollectionOf(type) {
            return type + ' { ? }';
        }

        function collectionOf(type, size, entries, indent) {
            var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
            return type + ' (' + size + ') {' + joinedEntries + '}';
        }

        function singleLineValues(xs) {
            for (var i = 0; i < xs.length; i++) {
                if (indexOf(xs[i], '\n') >= 0) {
                    return false;
                }
            }
            return true;
        }

        function getIndent(opts, depth) {
            var baseIndent;
            if (opts.indent === '\t') {
                baseIndent = '\t';
            } else if (typeof opts.indent === 'number' && opts.indent > 0) {
                baseIndent = $join.call(Array(opts.indent + 1), ' ');
            } else {
                return null;
            }
            return {
                base: baseIndent,
                prev: $join.call(Array(depth + 1), baseIndent)
            };
        }

        function indentedJoin(xs, indent) {
            if (xs.length === 0) { return ''; }
            var lineJoiner = '\n' + indent.prev + indent.base;
            return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
        }

        function arrObjKeys(obj, inspect) {
            var isArr = isArray(obj);
            var xs = [];
            if (isArr) {
                xs.length = obj.length;
                for (var i = 0; i < obj.length; i++) {
                    xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
                }
            }
            var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
            var symMap;
            if (hasShammedSymbols) {
                symMap = {};
                for (var k = 0; k < syms.length; k++) {
                    symMap['$' + syms[k]] = syms[k];
                }
            }

            for (var key in obj) { // eslint-disable-line no-restricted-syntax
                if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
                if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
                if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
                    // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
                    continue; // eslint-disable-line no-restricted-syntax, no-continue
                } else if ($test.call(/[^\w$]/, key)) {
                    xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
                } else {
                    xs.push(key + ': ' + inspect(obj[key], obj));
                }
            }
            if (typeof gOPS === 'function') {
                for (var j = 0; j < syms.length; j++) {
                    if (isEnumerable.call(obj, syms[j])) {
                        xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
                    }
                }
            }
            return xs;
        }

    }, { "./util.inspect": 1 }],
    34: [function(require, module, exports) {
        'use strict';

        var numberIsNaN = function(value) {
            return value !== value;
        };

        module.exports = function is(a, b) {
            if (a === 0 && b === 0) {
                return 1 / a === 1 / b;
            }
            if (a === b) {
                return true;
            }
            if (numberIsNaN(a) && numberIsNaN(b)) {
                return true;
            }
            return false;
        };


    }, {}],
    35: [function(require, module, exports) {
        'use strict';

        var define = require('define-properties');
        var callBind = require('call-bind');

        var implementation = require('./implementation');
        var getPolyfill = require('./polyfill');
        var shim = require('./shim');

        var polyfill = callBind(getPolyfill(), Object);

        define(polyfill, {
            getPolyfill: getPolyfill,
            implementation: implementation,
            shim: shim
        });

        module.exports = polyfill;

    }, { "./implementation": 34, "./polyfill": 36, "./shim": 37, "call-bind": 5, "define-properties": 7 }],
    36: [function(require, module, exports) {
        'use strict';

        var implementation = require('./implementation');

        module.exports = function getPolyfill() {
            return typeof Object.is === 'function' ? Object.is : implementation;
        };

    }, { "./implementation": 34 }],
    37: [function(require, module, exports) {
        'use strict';

        var getPolyfill = require('./polyfill');
        var define = require('define-properties');

        module.exports = function shimObjectIs() {
            var polyfill = getPolyfill();
            define(Object, { is: polyfill }, {
                is: function testObjectIs() {
                    return Object.is !== polyfill;
                }
            });
            return polyfill;
        };

    }, { "./polyfill": 36, "define-properties": 7 }],
    38: [function(require, module, exports) {
        'use strict';

        var keysShim;
        if (!Object.keys) {
            // modified from https://github.com/es-shims/es5-shim
            var has = Object.prototype.hasOwnProperty;
            var toStr = Object.prototype.toString;
            var isArgs = require('./isArguments'); // eslint-disable-line global-require
            var isEnumerable = Object.prototype.propertyIsEnumerable;
            var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
            var hasProtoEnumBug = isEnumerable.call(function() {}, 'prototype');
            var dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];
            var equalsConstructorPrototype = function(o) {
                var ctor = o.constructor;
                return ctor && ctor.prototype === o;
            };
            var excludedKeys = {
                $applicationCache: true,
                $console: true,
                $external: true,
                $frame: true,
                $frameElement: true,
                $frames: true,
                $innerHeight: true,
                $innerWidth: true,
                $onmozfullscreenchange: true,
                $onmozfullscreenerror: true,
                $outerHeight: true,
                $outerWidth: true,
                $pageXOffset: true,
                $pageYOffset: true,
                $parent: true,
                $scrollLeft: true,
                $scrollTop: true,
                $scrollX: true,
                $scrollY: true,
                $self: true,
                $webkitIndexedDB: true,
                $webkitStorageInfo: true,
                $window: true
            };
            var hasAutomationEqualityBug = (function() {
                /* global window */
                if (typeof window === 'undefined') { return false; }
                for (var k in window) {
                    try {
                        if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
                            try {
                                equalsConstructorPrototype(window[k]);
                            } catch (e) {
                                return true;
                            }
                        }
                    } catch (e) {
                        return true;
                    }
                }
                return false;
            }());
            var equalsConstructorPrototypeIfNotBuggy = function(o) {
                /* global window */
                if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
                    return equalsConstructorPrototype(o);
                }
                try {
                    return equalsConstructorPrototype(o);
                } catch (e) {
                    return false;
                }
            };

            keysShim = function keys(object) {
                var isObject = object !== null && typeof object === 'object';
                var isFunction = toStr.call(object) === '[object Function]';
                var isArguments = isArgs(object);
                var isString = isObject && toStr.call(object) === '[object String]';
                var theKeys = [];

                if (!isObject && !isFunction && !isArguments) {
                    throw new TypeError('Object.keys called on a non-object');
                }

                var skipProto = hasProtoEnumBug && isFunction;
                if (isString && object.length > 0 && !has.call(object, 0)) {
                    for (var i = 0; i < object.length; ++i) {
                        theKeys.push(String(i));
                    }
                }

                if (isArguments && object.length > 0) {
                    for (var j = 0; j < object.length; ++j) {
                        theKeys.push(String(j));
                    }
                } else {
                    for (var name in object) {
                        if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                            theKeys.push(String(name));
                        }
                    }
                }

                if (hasDontEnumBug) {
                    var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

                    for (var k = 0; k < dontEnums.length; ++k) {
                        if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
                            theKeys.push(dontEnums[k]);
                        }
                    }
                }
                return theKeys;
            };
        }
        module.exports = keysShim;

    }, { "./isArguments": 40 }],
    39: [function(require, module, exports) {
        'use strict';

        var slice = Array.prototype.slice;
        var isArgs = require('./isArguments');

        var origKeys = Object.keys;
        var keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');

        var originalKeys = Object.keys;

        keysShim.shim = function shimObjectKeys() {
            if (Object.keys) {
                var keysWorksWithArguments = (function() {
                    // Safari 5.0 bug
                    var args = Object.keys(arguments);
                    return args && args.length === arguments.length;
                }(1, 2));
                if (!keysWorksWithArguments) {
                    Object.keys = function keys(object) { // eslint-disable-line func-name-matching
                        if (isArgs(object)) {
                            return originalKeys(slice.call(object));
                        }
                        return originalKeys(object);
                    };
                }
            } else {
                Object.keys = keysShim;
            }
            return Object.keys || keysShim;
        };

        module.exports = keysShim;

    }, { "./implementation": 38, "./isArguments": 40 }],
    40: [function(require, module, exports) {
        'use strict';

        var toStr = Object.prototype.toString;

        module.exports = function isArguments(value) {
            var str = toStr.call(value);
            var isArgs = str === '[object Arguments]';
            if (!isArgs) {
                isArgs = str !== '[object Array]' &&
                    value !== null &&
                    typeof value === 'object' &&
                    typeof value.length === 'number' &&
                    value.length >= 0 &&
                    toStr.call(value.callee) === '[object Function]';
            }
            return isArgs;
        };

    }, {}],
    41: [function(require, module, exports) {
        'use strict';

        // modified from https://github.com/es-shims/es6-shim
        var keys = require('object-keys');
        var canBeObject = function(obj) {
            return typeof obj !== 'undefined' && obj !== null;
        };
        var hasSymbols = require('has-symbols/shams')();
        var callBound = require('call-bind/callBound');
        var toObject = Object;
        var $push = callBound('Array.prototype.push');
        var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
        var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;

        // eslint-disable-next-line no-unused-vars
        module.exports = function assign(target, source1) {
            if (!canBeObject(target)) { throw new TypeError('target must be an object'); }
            var objTarget = toObject(target);
            var s, source, i, props, syms, value, key;
            for (s = 1; s < arguments.length; ++s) {
                source = toObject(arguments[s]);
                props = keys(source);
                var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
                if (getSymbols) {
                    syms = getSymbols(source);
                    for (i = 0; i < syms.length; ++i) {
                        key = syms[i];
                        if ($propIsEnumerable(source, key)) {
                            $push(props, key);
                        }
                    }
                }
                for (i = 0; i < props.length; ++i) {
                    key = props[i];
                    value = source[key];
                    if ($propIsEnumerable(source, key)) {
                        objTarget[key] = value;
                    }
                }
            }
            return objTarget;
        };

    }, { "call-bind/callBound": 4, "has-symbols/shams": 16, "object-keys": 39 }],
    42: [function(require, module, exports) {
        'use strict';

        var defineProperties = require('define-properties');
        var callBind = require('call-bind');

        var implementation = require('./implementation');
        var getPolyfill = require('./polyfill');
        var shim = require('./shim');

        var polyfill = callBind.apply(getPolyfill());
        // eslint-disable-next-line no-unused-vars
        var bound = function assign(target, source1) {
            return polyfill(Object, arguments);
        };

        defineProperties(bound, {
            getPolyfill: getPolyfill,
            implementation: implementation,
            shim: shim
        });

        module.exports = bound;

    }, { "./implementation": 41, "./polyfill": 43, "./shim": 44, "call-bind": 5, "define-properties": 7 }],
    43: [function(require, module, exports) {
        'use strict';

        var implementation = require('./implementation');

        var lacksProperEnumerationOrder = function() {
            if (!Object.assign) {
                return false;
            }
            /*
             * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
             * note: this does not detect the bug unless there's 20 characters
             */
            var str = 'abcdefghijklmnopqrst';
            var letters = str.split('');
            var map = {};
            for (var i = 0; i < letters.length; ++i) {
                map[letters[i]] = letters[i];
            }
            var obj = Object.assign({}, map);
            var actual = '';
            for (var k in obj) {
                actual += k;
            }
            return str !== actual;
        };

        var assignHasPendingExceptions = function() {
            if (!Object.assign || !Object.preventExtensions) {
                return false;
            }
            /*
             * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
             * which is 72% slower than our shim, and Firefox 40's native implementation.
             */
            var thrower = Object.preventExtensions({ 1: 2 });
            try {
                Object.assign(thrower, 'xy');
            } catch (e) {
                return thrower[1] === 'y';
            }
            return false;
        };

        module.exports = function getPolyfill() {
            if (!Object.assign) {
                return implementation;
            }
            if (lacksProperEnumerationOrder()) {
                return implementation;
            }
            if (assignHasPendingExceptions()) {
                return implementation;
            }
            return Object.assign;
        };

    }, { "./implementation": 41 }],
    44: [function(require, module, exports) {
        'use strict';

        var define = require('define-properties');
        var getPolyfill = require('./polyfill');

        module.exports = function shimAssign() {
            var polyfill = getPolyfill();
            define(
                Object, { assign: polyfill }, { assign: function() { return Object.assign !== polyfill; } }
            );
            return polyfill;
        };

    }, { "./polyfill": 43, "define-properties": 7 }],
    45: [function(require, module, exports) {
        'use strict';

        var $Object = Object;
        var $TypeError = TypeError;

        module.exports = function flags() {
            if (this != null && this !== $Object(this)) {
                throw new $TypeError('RegExp.prototype.flags getter called on non-object');
            }
            var result = '';
            if (this.hasIndices) {
                result += 'd';
            }
            if (this.global) {
                result += 'g';
            }
            if (this.ignoreCase) {
                result += 'i';
            }
            if (this.multiline) {
                result += 'm';
            }
            if (this.dotAll) {
                result += 's';
            }
            if (this.unicode) {
                result += 'u';
            }
            if (this.sticky) {
                result += 'y';
            }
            return result;
        };

    }, {}],
    46: [function(require, module, exports) {
        'use strict';

        var define = require('define-properties');
        var callBind = require('call-bind');

        var implementation = require('./implementation');
        var getPolyfill = require('./polyfill');
        var shim = require('./shim');

        var flagsBound = callBind(getPolyfill());

        define(flagsBound, {
            getPolyfill: getPolyfill,
            implementation: implementation,
            shim: shim
        });

        module.exports = flagsBound;

    }, { "./implementation": 45, "./polyfill": 47, "./shim": 48, "call-bind": 5, "define-properties": 7 }],
    47: [function(require, module, exports) {
        'use strict';

        var implementation = require('./implementation');

        var supportsDescriptors = require('define-properties').supportsDescriptors;
        var $gOPD = Object.getOwnPropertyDescriptor;

        module.exports = function getPolyfill() {
            if (supportsDescriptors && (/a/mig).flags === 'gim') {
                var descriptor = $gOPD(RegExp.prototype, 'flags');
                if (descriptor && typeof descriptor.get === 'function' && typeof(/a/).dotAll === 'boolean') {
                    return descriptor.get;
                }
            }
            return implementation;
        };

    }, { "./implementation": 45, "define-properties": 7 }],
    48: [function(require, module, exports) {
        'use strict';

        var supportsDescriptors = require('define-properties').supportsDescriptors;
        var getPolyfill = require('./polyfill');
        var gOPD = Object.getOwnPropertyDescriptor;
        var defineProperty = Object.defineProperty;
        var TypeErr = TypeError;
        var getProto = Object.getPrototypeOf;
        var regex = /a/;

        module.exports = function shimFlags() {
            if (!supportsDescriptors || !getProto) {
                throw new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
            }
            var polyfill = getPolyfill();
            var proto = getProto(regex);
            var descriptor = gOPD(proto, 'flags');
            if (!descriptor || descriptor.get !== polyfill) {
                defineProperty(proto, 'flags', {
                    configurable: true,
                    enumerable: false,
                    get: polyfill
                });
            }
            return polyfill;
        };

    }, { "./polyfill": 47, "define-properties": 7 }],
    49: [function(require, module, exports) {
        'use strict';

        var GetIntrinsic = require('get-intrinsic');
        var callBound = require('call-bind/callBound');
        var inspect = require('object-inspect');

        var $TypeError = GetIntrinsic('%TypeError%');
        var $WeakMap = GetIntrinsic('%WeakMap%', true);
        var $Map = GetIntrinsic('%Map%', true);

        var $weakMapGet = callBound('WeakMap.prototype.get', true);
        var $weakMapSet = callBound('WeakMap.prototype.set', true);
        var $weakMapHas = callBound('WeakMap.prototype.has', true);
        var $mapGet = callBound('Map.prototype.get', true);
        var $mapSet = callBound('Map.prototype.set', true);
        var $mapHas = callBound('Map.prototype.has', true);

        /*
         * This function traverses the list returning the node corresponding to the
         * given key.
         *
         * That node is also moved to the head of the list, so that if it's accessed
         * again we don't need to traverse the whole list. By doing so, all the recently
         * used nodes can be accessed relatively quickly.
         */
        var listGetNode = function(list, key) { // eslint-disable-line consistent-return
            for (var prev = list, curr;
                (curr = prev.next) !== null; prev = curr) {
                if (curr.key === key) {
                    prev.next = curr.next;
                    curr.next = list.next;
                    list.next = curr; // eslint-disable-line no-param-reassign
                    return curr;
                }
            }
        };

        var listGet = function(objects, key) {
            var node = listGetNode(objects, key);
            return node && node.value;
        };
        var listSet = function(objects, key, value) {
            var node = listGetNode(objects, key);
            if (node) {
                node.value = value;
            } else {
                // Prepend the new node to the beginning of the list
                objects.next = { // eslint-disable-line no-param-reassign
                    key: key,
                    next: objects.next,
                    value: value
                };
            }
        };
        var listHas = function(objects, key) {
            return !!listGetNode(objects, key);
        };

        module.exports = function getSideChannel() {
            var $wm;
            var $m;
            var $o;
            var channel = {
                assert: function(key) {
                    if (!channel.has(key)) {
                        throw new $TypeError('Side channel does not contain ' + inspect(key));
                    }
                },
                get: function(key) { // eslint-disable-line consistent-return
                    if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                        if ($wm) {
                            return $weakMapGet($wm, key);
                        }
                    } else if ($Map) {
                        if ($m) {
                            return $mapGet($m, key);
                        }
                    } else {
                        if ($o) { // eslint-disable-line no-lonely-if
                            return listGet($o, key);
                        }
                    }
                },
                has: function(key) {
                    if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                        if ($wm) {
                            return $weakMapHas($wm, key);
                        }
                    } else if ($Map) {
                        if ($m) {
                            return $mapHas($m, key);
                        }
                    } else {
                        if ($o) { // eslint-disable-line no-lonely-if
                            return listHas($o, key);
                        }
                    }
                    return false;
                },
                set: function(key, value) {
                    if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                        if (!$wm) {
                            $wm = new $WeakMap();
                        }
                        $weakMapSet($wm, key, value);
                    } else if ($Map) {
                        if (!$m) {
                            $m = new $Map();
                        }
                        $mapSet($m, key, value);
                    } else {
                        if (!$o) {
                            /*
                             * Initialize the linked list as an empty node, so that we don't have
                             * to special-case handling of the first node: we can always refer to
                             * it as (previous node).next, instead of something like (list).head
                             */
                            $o = { key: {}, next: null };
                        }
                        listSet($o, key, value);
                    }
                }
            };
            return channel;
        };

    }, { "call-bind/callBound": 4, "get-intrinsic": 13, "object-inspect": 33 }],
    50: [function(require, module, exports) {
        'use strict';

        var isString = require('is-string');
        var isNumber = require('is-number-object');
        var isBoolean = require('is-boolean-object');
        var isSymbol = require('is-symbol');
        var isBigInt = require('is-bigint');

        // eslint-disable-next-line consistent-return
        module.exports = function whichBoxedPrimitive(value) {
            // eslint-disable-next-line eqeqeq
            if (value == null || (typeof value !== 'object' && typeof value !== 'function')) {
                return null;
            }
            if (isString(value)) {
                return 'String';
            }
            if (isNumber(value)) {
                return 'Number';
            }
            if (isBoolean(value)) {
                return 'Boolean';
            }
            if (isSymbol(value)) {
                return 'Symbol';
            }
            if (isBigInt(value)) {
                return 'BigInt';
            }
        };

    }, { "is-bigint": 20, "is-boolean-object": 21, "is-number-object": 24, "is-string": 27, "is-symbol": 28 }],
    51: [function(require, module, exports) {
        'use strict';

        var isMap = require('is-map');
        var isSet = require('is-set');
        var isWeakMap = require('is-weakmap');
        var isWeakSet = require('is-weakset');

        module.exports = function whichCollection(value) {
            if (value && typeof value === 'object') {
                if (isMap(value)) {
                    return 'Map';
                }
                if (isSet(value)) {
                    return 'Set';
                }
                if (isWeakMap(value)) {
                    return 'WeakMap';
                }
                if (isWeakSet(value)) {
                    return 'WeakSet';
                }
            }
            return false;
        };

    }, { "is-map": 23, "is-set": 26, "is-weakmap": 30, "is-weakset": 31 }],
    52: [function(require, module, exports) {
        (function(global) {
            (function() {
                'use strict';

                var forEach = require('foreach');
                var availableTypedArrays = require('available-typed-arrays');
                var callBound = require('call-bind/callBound');

                var $toString = callBound('Object.prototype.toString');
                var hasToStringTag = require('has-tostringtag/shams')();

                var g = typeof globalThis === 'undefined' ? global : globalThis;
                var typedArrays = availableTypedArrays();

                var $slice = callBound('String.prototype.slice');
                var toStrTags = {};
                var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
                var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
                if (hasToStringTag && gOPD && getPrototypeOf) {
                    forEach(typedArrays, function(typedArray) {
                        if (typeof g[typedArray] === 'function') {
                            var arr = new g[typedArray]();
                            if (Symbol.toStringTag in arr) {
                                var proto = getPrototypeOf(arr);
                                var descriptor = gOPD(proto, Symbol.toStringTag);
                                if (!descriptor) {
                                    var superProto = getPrototypeOf(proto);
                                    descriptor = gOPD(superProto, Symbol.toStringTag);
                                }
                                toStrTags[typedArray] = descriptor.get;
                            }
                        }
                    });
                }

                var tryTypedArrays = function tryAllTypedArrays(value) {
                    var foundName = false;
                    forEach(toStrTags, function(getter, typedArray) {
                        if (!foundName) {
                            try {
                                var name = getter.call(value);
                                if (name === typedArray) {
                                    foundName = name;
                                }
                            } catch (e) {}
                        }
                    });
                    return foundName;
                };

                var isTypedArray = require('is-typed-array');

                module.exports = function whichTypedArray(value) {
                    if (!isTypedArray(value)) { return false; }
                    if (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }
                    return tryTypedArrays(value);
                };

            }).call(this)
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, { "available-typed-arrays": 3, "call-bind/callBound": 4, "es-abstract/helpers/getOwnPropertyDescriptor": 8, "foreach": 10, "has-tostringtag/shams": 17, "is-typed-array": 29 }],
    53: [function(require, module, exports) {
        TAF.setExport(
            import.meta.url, {
                default: require("deep-equal")
            }
        )
    }, { "deep-equal": 6 }]
}, {}, [53]);